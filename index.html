<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Asteroids</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    html { height: 100%; overflow: hidden; }
    * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; }
    body {
      position: fixed; inset: 0;
      display: grid; place-items: center;
      background: #000;
      overflow: hidden;
      user-select: none; -webkit-user-select: none;
    }
    /*
      Pure-CSS scaling — reliable on all Android browsers.
      Canvas keeps its 900×650 resolution; CSS shrinks it to fit any screen.
    */
    #gameCanvas {
      display: block;
      width:  min(100vw, calc(100vh * 1.38462));
      height: min(100vh, calc(100vw * 0.72222));
    }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>

// ─────────────────────────────────────────────
//  CANVAS  (internal resolution stays 900×650)
// ─────────────────────────────────────────────
const canvas = document.getElementById('gameCanvas');
const ctx    = canvas.getContext('2d');
const W = 900, H = 650;
canvas.width = W; canvas.height = H;

const FONT = "'Orbitron', 'Courier New', monospace";

// ─────────────────────────────────────────────
//  DEVICE DETECTION + FULLSCREEN
// ─────────────────────────────────────────────
const isTouchDevice = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;

/** Convert a Touch event point → canvas-space coordinates */
function canvasPos(touch) {
  const r = canvas.getBoundingClientRect();
  return {
    x: (touch.clientX - r.left) * (W / r.width),
    y: (touch.clientY - r.top)  * (H / r.height),
  };
}

function tryFullscreen() {
  try {
    const el = document.documentElement;
    if      (el.requestFullscreen)       el.requestFullscreen();
    else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
  } catch (_) {}
  try { screen.orientation?.lock('landscape').catch(() => {}); } catch (_) {}
}
document.addEventListener('touchstart', tryFullscreen, { once: true });

// ─────────────────────────────────────────────
//  SHIP SPEED CONFIGURATION
// ─────────────────────────────────────────────
const SPEED_CONFIGS = {
  slow:   { thrust: 0.12, maxSpd: 5.5, rotate: 0.048 },
  medium: { thrust: 0.20, maxSpd: 9.0, rotate: 0.062 },
  fast:   { thrust: 0.30, maxSpd: 14,  rotate: 0.078 },
};
let speedMode = localStorage.getItem('asteroidsSpeed') || 'medium';

// Speed-button rects on the start screen (canvas coords)
const SPEED_BTNS = (() => {
  const bw = 78, bh = 22, gap = 12;
  const sx = W / 2 - (bw * 3 + gap * 2) / 2;
  const cy = H / 2 + 96;
  return {
    slow:   { x: sx,                  y: cy, w: bw, h: bh },
    medium: { x: sx + bw + gap,       y: cy, w: bw, h: bh },
    fast:   { x: sx + (bw + gap) * 2, y: cy, w: bw, h: bh },
  };
})();

// ─────────────────────────────────────────────
//  TOUCH CONTROL LAYOUT
//  — Joystick (left half): horizontal = rotate, up = thrust
//  — Fire button (right side): shoot
// ─────────────────────────────────────────────
const JOYSTICK_MAX_R    = 72;
const JOYSTICK_DEAD_ROT = 8;   // very sensitive rotation
const JOYSTICK_DEAD_THR = 12;  // easy thrust trigger

const JOYSTICK_DEFAULT = { x: 145, y: H - 145 };  // ghost position when idle
const FIRE_BTN         = { x: W - 130, y: H - 130, r: 72 };

// ─────────────────────────────────────────────
//  GAME CONSTANTS
// ─────────────────────────────────────────────
const SHIP_SIZE       = 16;
const FRICTION        = 0.985;
const BULLET_SPEED    = 11;
const BULLET_LIFETIME = 58;
const SHOOT_COOLDOWN  = 13;

const ASTEROID_TIERS = {
  large:  { r: 62, score: 20,  speed: 0.9 },
  medium: { r: 30, score: 50,  speed: 1.7 },
  small:  { r: 14, score: 100, speed: 2.8 },
};
const SPLITS = { large: 'medium', medium: 'small', small: null };

const RESPAWN_DELAY   = 150;
const INVINCIBLE_TIME = 180;
const SAFE_SPAWN_DIST = 160;

// ─────────────────────────────────────────────
//  GAME STATE
// ─────────────────────────────────────────────
let gameState  = 'start';
let highScore  = parseInt(localStorage.getItem('asteroidsHigh') || '0');
let newRecord  = false;

let asteroids  = [];
let bullets    = [];
let particles  = [];

let score      = 0;
let lives      = 3;
let level      = 1;

let shipAlive    = true;
let respawnTimer = 0;
let invincTimer  = 0;
let shootTimer   = 0;

let levelAnnounce = { timer: 0, text: '' };

// ─────────────────────────────────────────────
//  TOUCH STATE
// ─────────────────────────────────────────────
let joystickTouch = null;  // { id, startX, startY, dx, dy }
let fireTouch     = null;  // { id }
const touchCtrl = {
  rotLeft: false, rotRight: false, rotFactor: 0,
  thrust: false, fire: false,
};

function clearTouches() {
  joystickTouch = null; fireTouch = null;
  touchCtrl.rotLeft = touchCtrl.rotRight = touchCtrl.thrust = touchCtrl.fire = false;
  touchCtrl.rotFactor = 0;
}

/** Assign a new touch to fire button or joystick */
function assignPlayTouch(id, p) {
  if (dist(p.x, p.y, FIRE_BTN.x, FIRE_BTN.y) < FIRE_BTN.r + 45 && !fireTouch) {
    fireTouch = { id }; return;
  }
  if (!joystickTouch) {
    joystickTouch = { id, startX: p.x, startY: p.y, dx: 0, dy: 0 };
  }
}

// ─────────────────────────────────────────────
//  STARFIELD
// ─────────────────────────────────────────────
const stars = Array.from({ length: 180 }, () => ({
  x:     Math.random() * W,
  y:     Math.random() * H,
  r:     Math.random() * 1.4 + 0.2,
  phase: Math.random() * Math.PI * 2,
  speed: Math.random() * 0.8 + 0.2,
}));

// ─────────────────────────────────────────────
//  INPUT — KEYBOARD
// ─────────────────────────────────────────────
const keys = {};
document.addEventListener('keydown', e => {
  if (['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code))
    e.preventDefault();
  if (!e.repeat && (e.code === 'Space' || e.code === 'Enter')) {
    if (gameState === 'start')    { startGame(); return; }
    if (gameState === 'gameover') { gameState = 'start'; return; }
  }
  keys[e.code] = true;
});
document.addEventListener('keyup', e => { keys[e.code] = false; });

// Desktop mouse: click speed buttons on start screen
canvas.addEventListener('click', e => {
  if (gameState !== 'start') return;
  const r = canvas.getBoundingClientRect();
  handleSpeedBtnHit({
    x: (e.clientX - r.left) * (W / r.width),
    y: (e.clientY - r.top)  * (H / r.height),
  });
});

// ─────────────────────────────────────────────
//  INPUT — TOUCH
// ─────────────────────────────────────────────
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  if (gameState === 'gameover') { gameState = 'start'; return; }
  if (gameState === 'start') {
    const p = canvasPos(e.changedTouches[0]);
    if (!handleSpeedBtnHit(p)) startGame();
    return;
  }
  for (const t of e.changedTouches) assignPlayTouch(t.identifier, canvasPos(t));
}, { passive: false });

canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  for (const t of e.changedTouches) {
    if (!joystickTouch || t.identifier !== joystickTouch.id) continue;
    const p = canvasPos(t);
    let dx = p.x - joystickTouch.startX;
    let dy = p.y - joystickTouch.startY;
    const d = Math.hypot(dx, dy);
    if (d > JOYSTICK_MAX_R) { dx = (dx / d) * JOYSTICK_MAX_R; dy = (dy / d) * JOYSTICK_MAX_R; }
    joystickTouch.dx = dx;
    joystickTouch.dy = dy;
  }
}, { passive: false });

canvas.addEventListener('touchend', e => {
  e.preventDefault();
  for (const t of e.changedTouches) {
    if (joystickTouch && t.identifier === joystickTouch.id) joystickTouch = null;
    if (fireTouch     && t.identifier === fireTouch.id)     fireTouch     = null;
  }
}, { passive: false });

canvas.addEventListener('touchcancel', () => clearTouches(), { passive: false });

function handleSpeedBtnHit(p) {
  for (const [mode, btn] of Object.entries(SPEED_BTNS)) {
    if (p.x >= btn.x && p.x <= btn.x + btn.w &&
        p.y >= btn.y && p.y <= btn.y + btn.h) {
      speedMode = mode;
      localStorage.setItem('asteroidsSpeed', speedMode);
      return true;
    }
  }
  return false;
}

// ─────────────────────────────────────────────
//  SHIP
// ─────────────────────────────────────────────
const ship = { x: W/2, y: H/2, angle: -Math.PI/2, vx: 0, vy: 0, thrusting: false };

function resetShip() {
  ship.x = W/2; ship.y = H/2;
  ship.angle = -Math.PI/2;
  ship.vx = 0; ship.vy = 0;
  ship.thrusting = false;
}

// ─────────────────────────────────────────────
//  GAME FLOW
// ─────────────────────────────────────────────
function startGame() {
  score = 0; lives = 3; level = 1; newRecord = false;
  asteroids = []; bullets = []; particles = [];
  levelAnnounce = { timer: 0, text: '' };
  clearTouches();
  resetShip();
  shipAlive   = true;
  invincTimer = INVINCIBLE_TIME;
  shootTimer  = SHOOT_COOLDOWN * 2;
  gameState   = 'playing';
  spawnWave();
}

// ─────────────────────────────────────────────
//  HELPERS
// ─────────────────────────────────────────────
function wrap(obj) {
  if (obj.x < 0) obj.x += W; if (obj.x > W) obj.x -= W;
  if (obj.y < 0) obj.y += H; if (obj.y > H) obj.y -= H;
}
function dist(ax, ay, bx, by) { return Math.hypot(ax - bx, ay - by); }

// ─────────────────────────────────────────────
//  DRAWING UTILITIES
// ─────────────────────────────────────────────
function neonStroke(color, glow, blur, lw, fn) {
  ctx.save();
  ctx.shadowColor = glow; ctx.shadowBlur = blur; ctx.strokeStyle = glow; ctx.lineWidth = lw + 1.2; fn();
  ctx.shadowBlur  = 0;    ctx.strokeStyle = color; ctx.lineWidth = lw; fn();
  ctx.restore();
}
function neonFill(color, glow, blur, fn) {
  ctx.save(); ctx.shadowColor = glow; ctx.shadowBlur = blur; ctx.fillStyle = color; fn(); ctx.restore();
}
function glowText(text, x, y, size, color, glow, blur) {
  ctx.save();
  ctx.font = `bold ${size}px ${FONT}`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.shadowColor = glow; ctx.shadowBlur = blur;
  ctx.fillStyle = glow.replace(/[\d.]+\)$/, '0.3)'); ctx.fillText(text, x, y);
  ctx.shadowBlur = blur * 0.5; ctx.fillStyle = color; ctx.fillText(text, x, y);
  ctx.shadowBlur = 4;                                  ctx.fillText(text, x, y);
  ctx.restore();
}

// ─────────────────────────────────────────────
//  PARTICLES
// ─────────────────────────────────────────────
function spawnParticles(x, y, count, colors, speed, lifetime) {
  for (let i = 0; i < count; i++) {
    const a = Math.random()*Math.PI*2, v = speed*(0.2+Math.random()*0.8);
    particles.push({ x, y, vx: Math.cos(a)*v, vy: Math.sin(a)*v,
      life: lifetime, maxLife: lifetime,
      color: colors[Math.floor(Math.random()*colors.length)],
      size:  1.2 + Math.random()*2.2 });
  }
}

// ─────────────────────────────────────────────
//  ASTEROIDS
// ─────────────────────────────────────────────
function makeVerts(r) {
  const n = 9 + Math.floor(Math.random()*4);
  return Array.from({ length: n }, (_, i) => {
    const a = (i/n)*Math.PI*2, d = r*(0.72+Math.random()*0.56);
    return [Math.cos(a)*d, Math.sin(a)*d];
  });
}
function createAsteroid(x, y, tier, pvx=0, pvy=0) {
  const cfg = ASTEROID_TIERS[tier];
  const a = Math.random()*Math.PI*2, spd = cfg.speed*(0.6+Math.random()*0.8);
  return { x, y, vx: Math.cos(a)*spd+pvx*0.25, vy: Math.sin(a)*spd+pvy*0.25,
    rotation: Math.random()*Math.PI*2, rotSpd: (Math.random()-0.5)*0.024,
    radius: cfg.r, score: cfg.score, tier, verts: makeVerts(cfg.r) };
}
function edgeSpawn() {
  const side = Math.floor(Math.random()*4);
  switch (side) {
    case 0: return [Math.random()*W, 0];
    case 1: return [Math.random()*W, H];
    case 2: return [0, Math.random()*H];
    default: return [W, Math.random()*H];
  }
}
function spawnWave() {
  const count = 3 + level;
  for (let i = 0; i < count; i++) {
    let x, y, t=0;
    do { [x,y] = edgeSpawn(); t++; } while (dist(x,y,ship.x,ship.y) < SAFE_SPAWN_DIST && t<30);
    asteroids.push(createAsteroid(x, y, 'large'));
  }
}

// ─────────────────────────────────────────────
//  BULLETS
// ─────────────────────────────────────────────
function spawnBullet() {
  if (shootTimer > 0 || !shipAlive) return;
  bullets.push({
    x:  ship.x + Math.cos(ship.angle)*SHIP_SIZE*1.1,
    y:  ship.y + Math.sin(ship.angle)*SHIP_SIZE*1.1,
    vx: Math.cos(ship.angle)*BULLET_SPEED + ship.vx*0.25,
    vy: Math.sin(ship.angle)*BULLET_SPEED + ship.vy*0.25,
    life: BULLET_LIFETIME,
  });
  shootTimer = SHOOT_COOLDOWN;
}

// ─────────────────────────────────────────────
//  COLLISION & EVENTS
// ─────────────────────────────────────────────
const ROCK_COLORS = ['rgba(80,200,140,1)','rgba(160,255,180,1)','rgba(255,255,200,1)','rgba(200,255,220,1)'];
const SHIP_COLORS = ['rgba(100,200,255,1)','rgba(200,240,255,1)','rgba(255,200,80,1)','rgba(255,120,40,1)','rgba(255,255,255,1)'];

function explodeAsteroid(a, idx) {
  const cnt = a.tier==='large'?18:a.tier==='medium'?11:7;
  const spd = a.tier==='large'?3.0:a.tier==='medium'?2.2:1.4;
  spawnParticles(a.x, a.y, cnt, ROCK_COLORS, spd, 38+Math.random()*20);
  asteroids.splice(idx, 1);
  const child = SPLITS[a.tier];
  if (child) {
    asteroids.push(createAsteroid(a.x, a.y, child,  a.vx,  a.vy));
    asteroids.push(createAsteroid(a.x, a.y, child, -a.vx, -a.vy));
  }
  if (asteroids.length === 0) {
    level++;
    levelAnnounce = { timer: 110, text: `LEVEL  ${level}` };
    setTimeout(spawnWave, 2000);
  }
}

function killShip() {
  shipAlive = false; ship.thrusting = false;
  lives--;
  spawnParticles(ship.x, ship.y, 30, SHIP_COLORS, 4.5, 65);
  if (lives <= 0) {
    respawnTimer = 99999;
    setTimeout(() => {
      const prev = parseInt(localStorage.getItem('asteroidsHigh')||'0');
      if (score > 0 && score > prev) {
        newRecord = true; highScore = score;
        localStorage.setItem('asteroidsHigh', highScore);
      }
      gameState = 'gameover';
    }, 1800);
  } else {
    respawnTimer = RESPAWN_DELAY;
  }
}

function handleCollisions() {
  outer:
  for (let bi = bullets.length-1; bi >= 0; bi--) {
    const b = bullets[bi];
    for (let ai = asteroids.length-1; ai >= 0; ai--) {
      const a = asteroids[ai];
      if (dist(b.x,b.y,a.x,a.y) < a.radius+2) {
        score += a.score; bullets.splice(bi,1); explodeAsteroid(a,ai); continue outer;
      }
    }
  }
  if (!shipAlive || invincTimer > 0) return;
  for (let ai = 0; ai < asteroids.length; ai++) {
    const a = asteroids[ai];
    if (dist(ship.x,ship.y,a.x,a.y) < a.radius+SHIP_SIZE*0.72) { killShip(); break; }
  }
}

// ─────────────────────────────────────────────
//  UPDATE
// ─────────────────────────────────────────────
function update() {
  for (const r of bgRocks) { r.x+=r.vx; r.y+=r.vy; r.rotation+=r.rotSpd; wrap(r); }
  if (gameState !== 'playing') return;

  const sCfg = SPEED_CONFIGS[speedMode];

  // ── Derive touch controls from joystick ──
  if (joystickTouch) {
    const { dx, dy } = joystickTouch;
    touchCtrl.rotLeft   = dx < -JOYSTICK_DEAD_ROT;
    touchCtrl.rotRight  = dx >  JOYSTICK_DEAD_ROT;
    touchCtrl.rotFactor = Math.min(1, Math.max(0,
      (Math.abs(dx) - JOYSTICK_DEAD_ROT) / (JOYSTICK_MAX_R - JOYSTICK_DEAD_ROT)));
    touchCtrl.thrust    = dy < -JOYSTICK_DEAD_THR;   // push up = thrust
  } else {
    touchCtrl.rotLeft = touchCtrl.rotRight = touchCtrl.thrust = false;
    touchCtrl.rotFactor = 0;
  }
  touchCtrl.fire = !!fireTouch;

  // ── Ship ──
  if (shipAlive) {
    const kLeft  = keys['ArrowLeft']  || keys['KeyA'];
    const kRight = keys['ArrowRight'] || keys['KeyD'];
    // Proportional rotation for touch, full speed for keyboard
    if (kLeft  || touchCtrl.rotLeft)  ship.angle -= sCfg.rotate * (kLeft  ? 1 : touchCtrl.rotFactor);
    if (kRight || touchCtrl.rotRight) ship.angle += sCfg.rotate * (kRight ? 1 : touchCtrl.rotFactor);

    ship.thrusting = !!(keys['ArrowUp'] || keys['KeyW'] || touchCtrl.thrust);
    if (ship.thrusting) {
      ship.vx += Math.cos(ship.angle) * sCfg.thrust;
      ship.vy += Math.sin(ship.angle) * sCfg.thrust;
    }

    const spd = Math.hypot(ship.vx, ship.vy);
    if (spd > sCfg.maxSpd) { ship.vx=(ship.vx/spd)*sCfg.maxSpd; ship.vy=(ship.vy/spd)*sCfg.maxSpd; }
    ship.vx *= FRICTION; ship.vy *= FRICTION;
    ship.x  += ship.vx;  ship.y  += ship.vy;
    wrap(ship);

    if (keys['Space'] || touchCtrl.fire) spawnBullet();
    if (shootTimer  > 0) shootTimer--;
    if (invincTimer > 0) invincTimer--;
  } else {
    respawnTimer--;
    if (respawnTimer <= 0 && lives > 0) { resetShip(); shipAlive=true; invincTimer=INVINCIBLE_TIME; }
  }

  for (let i=bullets.length-1; i>=0; i--) {
    const b=bullets[i]; b.x+=b.vx; b.y+=b.vy; b.life--; wrap(b);
    if (b.life<=0) bullets.splice(i,1);
  }
  for (const a of asteroids) { a.x+=a.vx; a.y+=a.vy; a.rotation+=a.rotSpd; wrap(a); }
  for (let i=particles.length-1; i>=0; i--) {
    const p=particles[i];
    p.x+=p.vx; p.y+=p.vy; p.vx*=0.97; p.vy*=0.97; p.life--;
    if (p.life<=0) particles.splice(i,1);
  }
  if (levelAnnounce.timer > 0) levelAnnounce.timer--;
  handleCollisions();
}

// ─────────────────────────────────────────────
//  DRAW — GAME OBJECTS
// ─────────────────────────────────────────────
function drawStars(t) {
  stars.forEach(s => {
    const a = 0.35+0.65*(0.5+0.5*Math.sin(t*s.speed+s.phase));
    ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2);
    ctx.fillStyle=`rgba(200,220,255,${a})`; ctx.fill();
  });
}

function drawShip() {
  const S = SHIP_SIZE;
  ctx.save(); ctx.translate(ship.x,ship.y); ctx.rotate(ship.angle);
  neonStroke('rgba(160,220,255,1)','rgba(80,180,255,1)',18,1.5,() => {
    ctx.beginPath();
    ctx.moveTo(S*1.1,0); ctx.lineTo(-S*0.65,-S*0.58); ctx.lineTo(-S*0.28,0); ctx.lineTo(-S*0.65,S*0.58);
    ctx.closePath(); ctx.stroke();
  });
  neonStroke('rgba(200,240,255,0.6)','rgba(100,200,255,0.6)',6,0.8,() => {
    ctx.beginPath(); ctx.moveTo(S*0.7,0); ctx.lineTo(-S*0.1,0); ctx.stroke();
  });
  if (ship.thrusting) {
    const fl=Math.random(), len=S*(0.7+fl*0.7), fw=S*0.22;
    neonStroke(`rgba(255,${(120+fl*80)|0},30,1)`,'rgba(255,100,0,1)',20,1.8,() => {
      ctx.beginPath(); ctx.moveTo(-S*0.28-2,-fw); ctx.lineTo(-S*0.28-len,0); ctx.lineTo(-S*0.28-2,fw); ctx.stroke();
    });
    neonStroke('rgba(255,240,180,1)','rgba(255,220,100,1)',8,1,() => {
      ctx.beginPath(); ctx.moveTo(-S*0.28-2,-fw*0.4); ctx.lineTo(-S*0.28-len*0.55,0); ctx.lineTo(-S*0.28-2,fw*0.4); ctx.stroke();
    });
  }
  ctx.restore();
}

function drawAsteroid(a) {
  ctx.save(); ctx.translate(a.x,a.y); ctx.rotate(a.rotation);
  neonStroke('rgba(140,215,170,1)','rgba(55,185,105,1)',14,1.5,() => {
    ctx.beginPath();
    a.verts.forEach(([vx,vy],i) => i ? ctx.lineTo(vx,vy) : ctx.moveTo(vx,vy));
    ctx.closePath(); ctx.stroke();
  });
  ctx.restore();
}

function drawBullet(b) {
  neonFill('rgba(255,255,160,1)','rgba(255,240,80,1)',10,() => {
    ctx.beginPath(); ctx.arc(b.x,b.y,2.2,0,Math.PI*2); ctx.fill();
  });
}

function drawParticle(p) {
  const alpha = p.life/p.maxLife;
  ctx.save(); ctx.globalAlpha=alpha;
  ctx.shadowColor=p.color; ctx.shadowBlur=6; ctx.fillStyle=p.color;
  ctx.beginPath(); ctx.arc(p.x,p.y,p.size*(0.3+0.7*alpha),0,Math.PI*2); ctx.fill();
  ctx.restore();
}

function drawVignette() {
  const g = ctx.createRadialGradient(W/2,H/2,H*0.35,W/2,H/2,H*0.78);
  g.addColorStop(0,'rgba(0,0,0,0)'); g.addColorStop(1,'rgba(0,0,8,0.55)');
  ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
}

// ─────────────────────────────────────────────
//  DRAW — HUD
// ─────────────────────────────────────────────
function drawMiniShip(cx, cy) {
  const s = 9;
  ctx.save(); ctx.translate(cx,cy); ctx.rotate(-Math.PI/2);
  neonStroke('rgba(160,220,255,0.85)','rgba(80,180,255,0.85)',8,1,() => {
    ctx.beginPath();
    ctx.moveTo(s*1.1,0); ctx.lineTo(-s*0.65,-s*0.55); ctx.lineTo(-s*0.28,0); ctx.lineTo(-s*0.65,s*0.55);
    ctx.closePath(); ctx.stroke();
  });
  ctx.restore();
}

function drawHUD(t) {
  ctx.save();
  ctx.font=`9px ${FONT}`; ctx.textAlign='left'; ctx.textBaseline='middle';
  ctx.fillStyle='rgba(140,210,255,0.4)'; ctx.fillText('SCORE',28,22);
  ctx.font=`bold 22px ${FONT}`;
  ctx.shadowColor='rgba(80,180,255,1)'; ctx.shadowBlur=14; ctx.fillStyle='rgba(200,235,255,1)';
  ctx.fillText(score.toString().padStart(6,'0'),28,45);
  ctx.restore();

  ctx.save();
  ctx.font=`8px ${FONT}`; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillStyle='rgba(120,200,255,0.32)'; ctx.fillText('BEST',W/2,22);
  ctx.font=`bold 16px ${FONT}`;
  ctx.shadowColor='rgba(80,180,255,0.7)'; ctx.shadowBlur=8; ctx.fillStyle='rgba(160,220,255,0.5)';
  ctx.fillText(highScore.toString().padStart(6,'0'),W/2,43);
  ctx.restore();

  ctx.save();
  ctx.font=`8px ${FONT}`; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillStyle='rgba(100,200,130,0.32)'; ctx.fillText(`LVL  ${level}`,W/2,62);
  ctx.restore();

  for (let i=0; i<lives; i++) drawMiniShip(W-26-i*26,38);

  if (levelAnnounce.timer > 0) {
    const tm = levelAnnounce.timer;
    const alpha = tm>88?(110-tm)/22:tm<22?tm/22:1;
    ctx.save(); ctx.globalAlpha=alpha;
    glowText(levelAnnounce.text,W/2,H/2,44,'rgba(200,240,255,1)','rgba(80,180,255,1)',32);
    ctx.restore();
  }
}

// ─────────────────────────────────────────────
//  DRAW — TOUCH CONTROLS
// ─────────────────────────────────────────────
function drawTouchControls() {
  // ──────────────────────────────────────────
  //  JOYSTICK  (always visible)
  // ──────────────────────────────────────────
  const active = !!joystickTouch;
  const cx = active ? joystickTouch.startX : JOYSTICK_DEFAULT.x;
  const cy = active ? joystickTouch.startY : JOYSTICK_DEFAULT.y;
  const dx = active ? joystickTouch.dx : 0;
  const dy = active ? joystickTouch.dy : 0;

  ctx.save();
  ctx.globalAlpha = active ? 0.80 : 0.42;

  // Outer ring
  ctx.beginPath(); ctx.arc(cx, cy, JOYSTICK_MAX_R, 0, Math.PI*2);
  ctx.strokeStyle = 'rgba(100,185,255,1)'; ctx.lineWidth = 1.8;
  ctx.shadowColor = 'rgba(80,160,255,1)'; ctx.shadowBlur = active ? 16 : 7;
  ctx.stroke();
  ctx.fillStyle = 'rgba(60,120,255,0.06)'; ctx.fill();

  // Direction hints (always shown, fade when active)
  if (!active) {
    ctx.font = '16px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillStyle = 'rgba(130,195,255,0.65)';
    const ro = JOYSTICK_MAX_R * 0.62;
    ctx.fillText('←', cx - ro, cy);
    ctx.fillText('→', cx + ro, cy);
    ctx.fillText('↑', cx, cy - ro);
  }

  // Stick
  ctx.beginPath(); ctx.arc(cx+dx, cy+dy, 27, 0, Math.PI*2);
  ctx.fillStyle   = active ? 'rgba(100,200,255,0.28)' : 'rgba(80,160,255,0.14)';
  ctx.strokeStyle = active ? 'rgba(160,225,255,0.95)' : 'rgba(120,190,255,0.6)';
  ctx.lineWidth   = 1.8;
  ctx.shadowColor = 'rgba(100,200,255,1)';
  ctx.shadowBlur  = active ? 20 : 6;
  ctx.fill(); ctx.stroke();

  ctx.restore();

  // ──────────────────────────────────────────
  //  FIRE BUTTON  (always visible)
  // ──────────────────────────────────────────
  const { x: fx, y: fy, r: fr } = FIRE_BTN;
  const fireOn = !!fireTouch;

  ctx.save();
  ctx.globalAlpha = fireOn ? 0.88 : 0.40;

  ctx.beginPath(); ctx.arc(fx, fy, fr, 0, Math.PI*2);
  ctx.fillStyle   = fireOn ? 'rgba(255,70,30,0.22)' : 'rgba(255,50,20,0.07)';
  ctx.fill();
  ctx.strokeStyle = fireOn ? 'rgba(255,110,55,1)' : 'rgba(255,85,40,0.85)';
  ctx.lineWidth   = fireOn ? 2.2 : 1.6;
  ctx.shadowColor = 'rgba(255,70,20,1)'; ctx.shadowBlur = fireOn ? 26 : 11;
  ctx.stroke();

  // Center dot
  ctx.beginPath(); ctx.arc(fx, fy, fireOn ? 16 : 11, 0, Math.PI*2);
  ctx.fillStyle = fireOn ? 'rgba(255,185,80,1)' : 'rgba(255,120,60,0.75)';
  ctx.shadowBlur = fireOn ? 22 : 9; ctx.fill();

  ctx.restore();
}

// ─────────────────────────────────────────────
//  DRAW — START SCREEN
// ─────────────────────────────────────────────
function drawStartScreen(t) {
  bgRocks.forEach(a => { ctx.save(); ctx.globalAlpha=0.22; drawAsteroid(a); ctx.restore(); });

  glowText('ASTEROIDS',W/2,H/2-108,70,'rgba(200,235,255,1)','rgba(80,180,255,1)',42);

  ctx.save();
  ctx.font=`bold 13px ${FONT}`; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.shadowColor='rgba(60,200,130,0.8)'; ctx.shadowBlur=12; ctx.fillStyle='rgba(100,220,160,0.7)';
  ctx.fillText('NEON  EDITION',W/2,H/2-57);
  ctx.restore();

  ctx.save();
  ctx.strokeStyle='rgba(80,180,255,0.14)'; ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(W/2-148,H/2-28); ctx.lineTo(W/2+148,H/2-28); ctx.stroke();
  ctx.restore();

  const controls = [['↑  /  W','THRUST'],['← →  /  A D','ROTATE'],['SPACE','FIRE']];
  controls.forEach(([key,action],i) => {
    const y = H/2+2+i*27;
    ctx.save();
    ctx.font=`11px ${FONT}`; ctx.textAlign='right'; ctx.textBaseline='middle';
    ctx.shadowColor='rgba(80,180,255,0.5)'; ctx.shadowBlur=5; ctx.fillStyle='rgba(160,220,255,0.8)';
    ctx.fillText(key, W/2-12, y);
    ctx.shadowBlur=0; ctx.font=`10px ${FONT}`; ctx.textAlign='left';
    ctx.fillStyle='rgba(120,190,255,0.38)'; ctx.fillText(action, W/2+22, y);
    ctx.restore();
  });

  // Speed selector
  ctx.save();
  ctx.font=`8px ${FONT}`; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillStyle='rgba(140,210,255,0.4)'; ctx.fillText('SPEED',W/2,H/2+82);
  ctx.restore();

  for (const [mode, btn] of Object.entries(SPEED_BTNS)) {
    const on = speedMode === mode;
    const labels = { slow:'SLOW', medium:'MEDIUM', fast:'FAST' };
    ctx.save();
    ctx.beginPath(); ctx.roundRect(btn.x, btn.y, btn.w, btn.h, 4);
    ctx.fillStyle   = on ? 'rgba(80,180,255,0.22)' : 'rgba(80,180,255,0.05)';
    ctx.fill();
    ctx.strokeStyle = on ? 'rgba(120,210,255,0.9)' : 'rgba(80,180,255,0.25)';
    ctx.lineWidth   = on ? 1.5 : 1;
    ctx.shadowColor = 'rgba(80,180,255,1)'; ctx.shadowBlur = on ? 12 : 0;
    ctx.stroke();
    ctx.font=`bold ${on?9:8}px ${FONT}`; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillStyle = on ? 'rgba(200,235,255,1)' : 'rgba(120,180,255,0.45)';
    ctx.shadowBlur = on ? 8 : 0;
    ctx.fillText(labels[mode], btn.x+btn.w/2, btn.y+btn.h/2);
    ctx.restore();
  }

  const pulse = 0.5+0.5*Math.sin(t*3.5);
  ctx.save(); ctx.globalAlpha=0.5+0.5*pulse;
  ctx.font=`bold 12px ${FONT}`; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.shadowColor='rgba(80,180,255,1)'; ctx.shadowBlur=14; ctx.fillStyle='rgba(200,235,255,1)';
  ctx.fillText(isTouchDevice ? 'TAP  TO  LAUNCH' : 'PRESS  SPACE  TO  LAUNCH', W/2, H/2+138);
  ctx.restore();
}

// ─────────────────────────────────────────────
//  DRAW — GAME OVER SCREEN
// ─────────────────────────────────────────────
function drawGameOverScreen(t) {
  ctx.save();
  ctx.fillStyle='rgba(0,0,10,0.80)'; ctx.fillRect(W/2-196,H/2-140,392,282);
  ctx.strokeStyle='rgba(80,180,255,0.12)'; ctx.lineWidth=1;
  ctx.strokeRect(W/2-196,H/2-140,392,282);
  ctx.restore();

  glowText('GAME  OVER',W/2,H/2-86,44,'rgba(255,180,80,1)','rgba(255,100,20,1)',36);

  ctx.save();
  ctx.font=`9px ${FONT}`; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillStyle='rgba(140,210,255,0.42)'; ctx.fillText('SCORE',W/2,H/2-22);
  ctx.font=`bold 30px ${FONT}`;
  ctx.shadowColor='rgba(80,180,255,0.8)'; ctx.shadowBlur=14; ctx.fillStyle='rgba(200,235,255,0.95)';
  ctx.fillText(score.toString().padStart(6,'0'),W/2,H/2+9);
  ctx.restore();

  if (newRecord && score > 0) {
    const pulse=0.6+0.4*Math.sin(t*4.5);
    ctx.save(); ctx.globalAlpha=pulse;
    ctx.font=`bold 12px ${FONT}`; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.shadowColor='rgba(255,220,60,1)'; ctx.shadowBlur=18; ctx.fillStyle='rgba(255,230,80,1)';
    ctx.fillText('★  NEW  RECORD  ★',W/2,H/2+54);
    ctx.restore();
  } else {
    ctx.save();
    ctx.font=`8px ${FONT}`; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillStyle='rgba(120,200,140,0.38)'; ctx.fillText('BEST',W/2,H/2+46);
    ctx.font=`13px ${FONT}`;
    ctx.shadowColor='rgba(60,190,110,0.6)'; ctx.shadowBlur=8; ctx.fillStyle='rgba(140,215,170,0.62)';
    ctx.fillText(highScore.toString().padStart(6,'0'),W/2,H/2+62);
    ctx.restore();
  }

  const pulse2=0.5+0.5*Math.sin(t*3.0);
  ctx.save(); ctx.globalAlpha=0.45+0.55*pulse2;
  ctx.font=`bold 11px ${FONT}`; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.shadowColor='rgba(80,180,255,0.6)'; ctx.shadowBlur=8; ctx.fillStyle='rgba(180,225,255,1)';
  ctx.fillText(isTouchDevice ? 'TAP  TO  PLAY  AGAIN' : 'PRESS  SPACE  TO  PLAY  AGAIN', W/2, H/2+108);
  ctx.restore();
}

// ─────────────────────────────────────────────
//  RENDER
// ─────────────────────────────────────────────
function render(t) {
  ctx.fillStyle='#00000a'; ctx.fillRect(0,0,W,H);
  drawStars(t);

  if (gameState==='playing' || gameState==='gameover') {
    asteroids.forEach(drawAsteroid);
    bullets.forEach(drawBullet);
    particles.forEach(drawParticle);
    if (shipAlive) {
      const vis = invincTimer<=0 || Math.floor(invincTimer/8)%2===0;
      if (vis) drawShip();
    }
    drawHUD(t);
  }

  drawVignette();

  if (gameState==='start')    drawStartScreen(t);
  if (gameState==='gameover') drawGameOverScreen(t);

  if (isTouchDevice && (gameState==='playing' || gameState==='gameover')) {
    drawTouchControls();
  }
}

// ─────────────────────────────────────────────
//  BACKGROUND ROCKS
// ─────────────────────────────────────────────
const bgRocks = Array.from({ length: 6 }, () => {
  const [x,y] = edgeSpawn();
  const rock = createAsteroid(x, y, Math.random()<0.5 ? 'large' : 'medium');
  rock.vx *= 0.35; rock.vy *= 0.35;
  return rock;
});

// ─────────────────────────────────────────────
//  GAME LOOP
// ─────────────────────────────────────────────
function loop(ts) { update(); render(ts*0.001); requestAnimationFrame(loop); }
requestAnimationFrame(loop);

</script>
</body>
</html>
